# GitLab CI/CD Pipeline for Enterprise Architecture Diagram Agent
# This pipeline builds, tests, and deploys the AI-powered architecture diagram generator

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  DOCKER_DRIVER: overlay2
  CONTAINER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  LATEST_IMAGE: $CI_REGISTRY_IMAGE:latest

stages:
  - validate
  - build
  - test
  - quality
  - package
  - deploy
  - architecture-analysis

# Cache Maven dependencies
cache:
  paths:
    - .m2/repository/

# Validate stage
validate:
  stage: validate
  image: maven:3.9-openjdk-21
  script:
    - mvn $MAVEN_CLI_OPTS validate
    - mvn $MAVEN_CLI_OPTS dependency:analyze
  only:
    - merge_requests
    - main
    - develop

# Build stage
build:
  stage: build
  image: maven:3.9-openjdk-21
  script:
    - mvn $MAVEN_CLI_OPTS clean compile
  artifacts:
    paths:
      - target/classes/
    expire_in: 1 hour
  only:
    - merge_requests
    - main
    - develop

# Unit Tests
unit-tests:
  stage: test
  image: maven:3.9-openjdk-21
  services:
    - postgres:15
    - redis:7
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_pass
    POSTGRES_HOST_AUTH_METHOD: trust
  script:
    - mvn $MAVEN_CLI_OPTS test
  artifacts:
    reports:
      junit:
        - target/surefire-reports/TEST-*.xml
    paths:
      - target/site/jacoco/
    expire_in: 1 week
  coverage: '/Total.*?([0-9]{1,3})%/'
  only:
    - merge_requests
    - main
    - develop

# Integration Tests
integration-tests:
  stage: test
  image: maven:3.9-openjdk-21
  services:
    - postgres:15
    - redis:7
    - name: gitlab/gitlab-ce:latest
      alias: gitlab
  variables:
    POSTGRES_DB: integration_test_db
    POSTGRES_USER: integration_user
    POSTGRES_PASSWORD: integration_pass
    POSTGRES_HOST_AUTH_METHOD: trust
    GITLAB_ROOT_PASSWORD: integration_test_password
  script:
    - mvn $MAVEN_CLI_OPTS verify -Pintegration-tests
  artifacts:
    reports:
      junit:
        - target/failsafe-reports/TEST-*.xml
    expire_in: 1 week
  only:
    - main
    - develop

# Code Quality Analysis
sonarqube-check:
  stage: quality
  image: maven:3.9-openjdk-21
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - mvn $MAVEN_CLI_OPTS verify sonar:sonar -Dsonar.qualitygate.wait=true
  allow_failure: true
  only:
    - main
    - develop
    - merge_requests

# Security Scan
security-scan:
  stage: quality
  image: maven:3.9-openjdk-21
  script:
    - mvn $MAVEN_CLI_OPTS org.owasp:dependency-check-maven:check
    - mvn $MAVEN_CLI_OPTS com.github.spotbugs:spotbugs-maven-plugin:check
  artifacts:
    reports:
      dependency_scanning: target/dependency-check-report.json
    paths:
      - target/dependency-check-report.html
      - target/spotbugsXml.xml
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - develop

# Package Application
package-jvm:
  stage: package
  image: maven:3.9-openjdk-21
  script:
    - mvn $MAVEN_CLI_OPTS clean package -DskipTests
  artifacts:
    paths:
      - target/quarkus-app/
    expire_in: 1 week
  only:
    - main
    - develop
    - tags

# Package Native Image (for production)
package-native:
  stage: package
  image: quay.io/quarkus/ubi-quarkus-mandrel-builder-image:jdk-21
  script:
    - mvn $MAVEN_CLI_OPTS clean package -Pnative -DskipTests
  artifacts:
    paths:
      - target/*-runner
    expire_in: 1 week
  only:
    - tags
  when: manual

# Build Docker Image
docker-build:
  stage: package
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -f src/main/docker/Dockerfile.jvm -t $CONTAINER_IMAGE .
    - docker tag $CONTAINER_IMAGE $LATEST_IMAGE
    - docker push $CONTAINER_IMAGE
    - docker push $LATEST_IMAGE
  dependencies:
    - package-jvm
  only:
    - main
    - develop
    - tags

# Deploy to Development Environment
deploy-dev:
  stage: deploy
  image: alpine/helm:latest
  environment:
    name: development
    url: https://arch-agent-dev.enterprise.com
  script:
    - helm upgrade --install arch-agent-dev helm/ 
        --set image.tag=$CI_COMMIT_SHORT_SHA
        --set environment=development
        --namespace arch-agent-dev
        --create-namespace
  dependencies:
    - docker-build
  only:
    - develop

# Deploy to Staging Environment
deploy-staging:
  stage: deploy
  image: alpine/helm:latest
  environment:
    name: staging
    url: https://arch-agent-staging.enterprise.com
  script:
    - helm upgrade --install arch-agent-staging helm/
        --set image.tag=$CI_COMMIT_SHORT_SHA
        --set environment=staging
        --namespace arch-agent-staging
        --create-namespace
  dependencies:
    - docker-build
  only:
    - main
  when: manual

# Deploy to Production Environment
deploy-prod:
  stage: deploy
  image: alpine/helm:latest
  environment:
    name: production
    url: https://arch-agent.enterprise.com
  script:
    - helm upgrade --install arch-agent-prod helm/
        --set image.tag=$CI_COMMIT_SHORT_SHA
        --set environment=production
        --namespace arch-agent-prod
        --create-namespace
  dependencies:
    - docker-build
  only:
    - tags
  when: manual

# Architecture Analysis Job
# This job demonstrates the agent analyzing its own repository
analyze-architecture:
  stage: architecture-analysis
  image: alpine/curl:latest
  variables:
    ARCH_AGENT_URL: "https://arch-agent-dev.enterprise.com"
  script:
    - |
      echo "üîç Analyzing repository architecture..."
      
      # Trigger architecture analysis
      ANALYSIS_RESPONSE=$(curl -s -X POST "$ARCH_AGENT_URL/api/v1/architecture/analyze" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $GITLAB_TOKEN" \
        -d '{
          "projectId": "'$CI_PROJECT_ID'",
          "branch": "'$CI_COMMIT_REF_NAME'",
          "commitSha": "'$CI_COMMIT_SHA'",
          "analysisType": "FULL",
          "diagramTypes": ["COMPONENT", "SEQUENCE", "CLASS"],
          "options": {
            "aiEnhanced": true,
            "detectPatterns": true,
            "includeDependencies": true
          }
        }')
      
      echo "Analysis response: $ANALYSIS_RESPONSE"
      
      # Extract analysis ID
      ANALYSIS_ID=$(echo $ANALYSIS_RESPONSE | jq -r '.analysisId')
      echo "Analysis ID: $ANALYSIS_ID"
      
      # Wait for analysis to complete (poll every 30 seconds for up to 10 minutes)
      for i in {1..20}; do
        sleep 30
        STATUS_RESPONSE=$(curl -s "$ARCH_AGENT_URL/api/v1/architecture/analysis/$ANALYSIS_ID")
        STATUS=$(echo $STATUS_RESPONSE | jq -r '.status')
        echo "Analysis status: $STATUS"
        
        if [ "$STATUS" = "COMPLETED" ]; then
          echo "‚úÖ Analysis completed successfully!"
          break
        elif [ "$STATUS" = "FAILED" ]; then
          echo "‚ùå Analysis failed!"
          exit 1
        fi
      done
      
      # Generate diagrams
      echo "üìä Generating architecture diagrams..."
      DIAGRAM_RESPONSE=$(curl -s -X POST "$ARCH_AGENT_URL/api/v1/architecture/diagrams/generate" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $GITLAB_TOKEN" \
        -d '{
          "analysisId": "'$ANALYSIS_ID'",
          "outputFormat": "markdown",
          "includeMetadata": true
        }')
      
      echo "Diagram generation response: $DIAGRAM_RESPONSE"
      echo "üéâ Architecture analysis and diagram generation completed!"
  dependencies:
    - deploy-dev
  only:
    - main
  when: manual
  allow_failure: true

# Cleanup old images
cleanup:
  stage: deploy
  image: alpine/curl:latest
  script:
    - |
      echo "üßπ Cleaning up old container images..."
      # Keep only the last 10 images
      # This would typically call GitLab Container Registry API
      echo "Cleanup completed"
  only:
    - schedules
  when: manual